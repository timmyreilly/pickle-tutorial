import pickle 

file_name = 'Referral.json';

file_name

file_name.capitalize

#file_name.capitalize.mro()

file_name.casefold
file_name.casefold()

x = file_name.casefold()

b = x.count

print (b) 

''' Is there a way to do continuous terminal debugging with python? ''' 

''' what do we know about b ''' 

# b = JSONObject(in file_name); 

# file_name has a value from the file that I'm trying to load and put into JSON for some reason. '

# What the heck was I trying to do. 
# This should al be in quoatations. But it's not be cause I've totally forgetten what I was doing. ''''''

# The whole forward and backward in time thing is driving me crazy. ' 
# ' 

# So let's say we have a string. 



# The string is defined by a '' 

# '' is empty right now. 

# x = '' now has empty contents. 

x = '' 

b = '' 

x + b 

print (x + b)

print("2")

# What the heck was that. 
# You added a 2 to that empty object. Nice! 

# let's do it again but with two numbers!"

print ("22"); 

#wait what's that thing? 

# I don't know don't look at it. 

print ("33333") 

# you can use it if you want. Sometimes it's required and sometimes its not. 
# You'll figure it our eventually. 

print("This is how you print text to the screen")

# let's print out something silly. 

print (" nnnn \ nnnn")

try:
    for x in 3: 
        print (" x ") 
except TypeError: 
    print ('woops') 

# Welp first of all that's an integer. 
# Integers are numbers: 3 is an integer. 

try: 
    for x in "":
        print (" x ")
except TypeError: 
    print ('woops') 

try: 
    for x in "xxx":
        print ( " x "); 
except TypeError: 
    print ('woops') # that's three woops yall 


# wait a second there are only 3 one woops... What happened back there?

print ( 'Part II') 


for x in "xxx":
    print (" x ") 


for x in "xxxvvv":
    print (" xx ")

for x in x: 
    print (" xxx ")

x = x 

x == x 

print ( x ) 

print (x ) 

x == x; 

try: 
    print ( x.value ) 
except:
    print (" woops ")

print ( x == x ) 

import math as Math; 

print( Math ) 

try: 
    Math.acos(3); 
except ValueError:
    print ( " woops acos takes more argumenents buddy. those arguments are " )

try:
    print ( Math ) 
except: 
    print ( " what" )

try:
    Math.acos(3.3); 
except ValueError:
    print ( " what ") 

print ( Math.floor(2) )

print ( Math.floor(2.2))

print ( Math.floor(3.3 + 3)) 

print (6 + 5) 

try: 
    print (x + 5) 
except TypeError:
    print (" not the right type " ) 

try: 
    print (str(x) + 5) 
except TypeError: 
    print (TypeError) 
    print (dir(TypeError()) )


print (" x ")

print ("Something you want to say... You'll use this everyone once in a while. ") 

# But you'll notice it isn't very helpful for more complex systems. It doesn't have a lot of flexibility on the screen. 

# So, what we look for is content that fits nicely in a small space but with a lot of complication. 

# So... let's look at an object that someone else has defined. You'll have to learn this if you want to do things. 

# I guess that's the easiest way of describing things, but I know you can do it. 

# THEY CAN"T STOP US NOW MWAHAHAHA" 
# We can help people! 

# First lets say there's a factory object. 
# This factory takes a bunch of cheeseburgers and eats them. 

# CheeseBurger array = "My Cheeseburgers All of them. All of the cheeseburgers ever"

# array CheeseBurger = "My Cheeseburgers all of them. all of the cheeseburgers ever made"

CheeseBurgers = "My Cheeseburger all of them. All of the cheeseburgers ever"; 

print( CheeseBurgers ) 
print( CheeseBurgers[0]) 

print ( "Okay so our first CheeseBurger is right there") 

try: 
    CheeseBurgers[11] = "d"
except TypeError: 
    print (TypeError()); 

print ("Wait what") 


print (CheeseBurgers[0]) 

print ( CheeseBurgers[11]) 

# Wait what... did that just print r? ...TypeError * over here with the humans right.

print (CheeseBurgers) 

print ( ' wait ')
print ( CheeseBurgers.expandtabs()); 

print (CheeseBurgers) 

# CheeseBurgers.eat() 

print ( CheeseBurgers.count("h") ) ; 

# 4? 

hs = CheeseBurgers.count("h")  

try: 
    for x in hs: 
        print (" x ") 
except TypeError:
    print ("whoops")
    print (TypeError.args)
    print (BaseException.args)   

print(hs) 

print (Math.pi)   

print (hs * Math.pi)

# Okay back to the cheeseburgers. 

p = print 
p(CheeseBurgers) 

p("hs")

class HamSandwichFactory :
    x = "h a" 

print (HamSandwichFactory.x)  

class HamSandwichFactoryTwo : 
    for x in [1,1,1]: 
        print("888")

# Wait I didn't print anything. I didn't even call that class... What gives? 

class HamSandwichFactoryThree :
    def funcname(self):
        print (self)

HamSandwichFactoryThree.funcname(HamSandwichFactoryThree); 

# Whoa wait what... I just printed <class '__main__.HamSandwichFactory' 

class HamSandwichFactoryFour : 
    def funcname(): 
        print ("hey!") 

HamSandwichFactoryFour.funcname()

class HamSandwichFactoryFive : 
    def funcname(parameter_list):
        pass
    def makeBurger(burgerGroup):
        burgerGroup = burgerGroup + "burger"; 
        print (burgerGroup) 


HamSandwichFactoryFive.makeBurger(CheeseBurgers)

print(CheeseBurgers) 
print(CheeseBurgers + "BURGER")

# Wait what the heck why doesn't HamSandwichFactoryFive.makeBurger(CheeseBurgers) change the value of Cheeseburger? 

fizz = HamSandwichFactoryFive(); 

try: 
    print(fizz.makeBurger("BurgerFactoryTwo")) 
except TypeError:
    print((TypeError)) 

fizzTwo = HamSandwichFactoryFive()

print( fizzTwo )  

class HamSandwichFactorySix: 
    value = '5'
    def setValue(newValue): 
        value = newValue 
    
    def getValue()
        return value

HSFS = 
